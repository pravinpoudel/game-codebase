{"version":3,"sources":["shortestPath.js"],"names":["shortestPathBinaryMatrix","grid","length","Map","queue","visited","row","col","lastRow","lastCol","neighbors","totalLength","Infinity","currentCol","_queue$shift","currentRow","currentLength","nextRow","nextCol","newLength","i"],"mappings":"aAAA,IAAIA,yBAA2B,SAAUC,GACvC,GAAoB,IAAhBA,EAAKC,OAAc,OAAQ,EADjC,IAAIF,EAAAA,GACEC,EAAA,IAAgBE,IACpB,GAAA,IAAMC,EAAK,GAAG,GAAd,OAAA,EACAA,EAAMC,KAAO,CAAAC,IAAOH,EAAJI,IAAhB,EAAAL,OAAA,IACA,IAAID,EAAAA,EAAJC,OAA8B,EAC9BE,EAAWH,EAAAA,EAAAC,OAAA,GAAAA,OAAA,EAAEI,GAAF,IAAEA,EAAFE,GAAAC,GAAA,OAAA,EAgBc,IAhBJF,IAAGG,EAAb,CAAkBR,EAAAA,GAAM,GAAnC,EAAA,EAAA,GACA,EAAMM,EAAAA,GAAN,CAAA,GACEC,GACF,CAAA,GAAIR,GACJ,CAAA,EAAMS,GAUN,CAAA,EAAIC,GAFF,CAAC,EAAG,IAImBA,EAAAC,EAAAA,EAAA,EAGhBC,EAAAA,QAHgB,CAAA,IAAAC,EAQrBC,EAAAA,QANKA,EAFgBD,EAErBR,IAIOO,EANcC,EAMvBP,IAFUS,EAJaF,EAIrBZ,OAQAS,EAAAA,GAAAA,OAAWI,EAAXJ,MAAAA,OAAuBA,GACvB,GACDI,IAAAP,GALCK,IAAeJ,GAMc,IAA/BR,EAAII,GAAAQ,IAIF,IAAgBE,IAAhBV,EAAMY,IAAUF,GAAhB,CACAV,EAAMa,IAAAA,GAAUL,GAChB,IAJF,IAAMM,EAAYH,EAAgB,EAI5Bf,EAAKgB,EAAAA,EAALP,EAAsBO,OAASC,IAAAA,CACjCd,IAAAA,EAAWW,EAAAL,EAAAU,GAAA,GAAEd,EAAFO,EAAAH,EAAAU,GAAA,GAAgBb,EAAKW,IAArB,IAAAjB,EAAAgB,GAAAC,IAA8BhB,EAAAA,KAAQiB,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,OAAAA,WALrDR,EAAkBK,KAAAA,IAAAA,EAAlBA,EAAA,GAQD,OAAAL,IAAAC,EAAAA,GAAA,EAAAD","file":"shortestPath.min.js","sourcesContent":["var shortestPathBinaryMatrix = function (grid) {\r\n  if (grid.length === 0) return -1;\r\n  const queue = [];\r\n  const visited = new Map();\r\n  if (grid[0][0] !== 0) return -1;\r\n  queue.push({ row: 0, col: 0, length: 0 });\r\n  const lastRow = grid.length - 1,\r\n    lastCol = grid[grid.length - 1].length - 1;\r\n  if (grid[lastRow][lastCol] !== 0) return -1;\r\n  const neighbors = [\r\n    [-1, -1],\r\n    [-1, 0],\r\n    [-1, 1],\r\n    [0, -1],\r\n    [1, -1],\r\n    [1, 0],\r\n    [1, 1],\r\n    [0, 1],\r\n  ];\r\n  let totalLength = Infinity;\r\n\r\n  while (queue.length > 0) {\r\n    const {\r\n      row: currentRow,\r\n      col: currentCol,\r\n      length: currentLength,\r\n    } = queue.shift();\r\n    const key = `${currentRow}::${currentCol}`;\r\n    if (\r\n      currentRow === lastRow &&\r\n      currentCol === lastCol &&\r\n      grid[currentRow][currentCol] === 0\r\n    ) {\r\n      totalLength = Math.min(totalLength, currentLength + 1);\r\n      continue;\r\n    }\r\n    if (visited.has(key) === true) continue;\r\n    visited.set(key, true);\r\n    const newLength = currentLength + 1;\r\n    for (let i = 0; i < neighbors.length; i++) {\r\n      const nextRow = currentRow + neighbors[i][0];\r\n      const nextCol = currentCol + neighbors[i][1];\r\n      if (grid[nextRow] && grid[nextRow][nextCol] === 0) {\r\n        queue.push({ row: nextRow, col: nextCol, length: newLength });\r\n      }\r\n    }\r\n  }\r\n  return totalLength === Infinity ? -1 : totalLength;\r\n};\r\n"]}