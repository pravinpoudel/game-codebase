{"version":3,"sources":["shortestPath.js"],"names":["findShortestLength","startIndex","endIndex","queue","distances","Array","comb1","shift","neighbours","cellIndex","cols","length","push","i","comb2","removedWallSet","rows","findShortestPath","path","currentDistance","hasOwnProperty","splice","x","y"],"mappings":"aAAA,SAASA,mBAAmBC,EAAYC,GACtC,IAEAC,EAAWF,EAFPE,EAAQ,GADdC,EAASJ,IAAAA,MAAmBC,KAAAA,MAAYC,MAAAA,GAItCE,IAHAD,EAAIA,KAAKF,GACTG,EAAIA,GAAgBC,EAEpB,EAAAD,EAAUH,QAAV,CACA,IAAIK,EAAJH,EAAAI,QAGMC,EAAa,CAACC,EAAYC,KAAMD,EAAYC,MAFlDD,EAAaE,MAAY,EACvBH,EAAaI,KAAGT,EAAhB,IACIK,EAAcC,MAAYC,KAAMD,GAElCD,EAAWI,KAAKH,EAAY,GAE5BD,EAAWI,KAAKH,EAAY,IAE5BD,IAAAA,IAAAA,EAAWI,EAAAA,EAAKH,EAAhBE,OAAAE,IAWAP,EAAAE,EAAAK,GAAA,IAAAJ,EACAK,EAAAL,EAAA,IAAAD,EAAAK,IAGKE,eAAGT,IAAsBG,eAA9BK,KAGMC,EAAeT,GAAfU,KAAyBD,MAAwB,GAAxBA,EAAwBF,KAFvDC,EAAQL,OAAYI,EAAZ,GAINA,KAID,IAAA,IAAAA,EAAA,EAAAA,EAAAL,EAAAG,OAAAE,IACF,IAAA,GAAAT,EAAAI,EAAAK,MAIGT,EAAUI,EAAWK,IAAMT,EAAUK,GAAa,EAFtDN,EAASU,KAATL,EAAoBA,IACdJ,EAAUI,IAAAA,GACZJ,OAASA,GAMZ,SAAAa,iBAAAhB,EAAAC,GACF,IAAAE,EAAAJ,mBAAAC,EAAAC,GACFO,EAAAP,EAKCgB,KAAKN,KAAKV,GAFV,IADF,IAAAiB,EAASF,EAAiBhB,GACRD,EAAZI,GAAYJ,CAChBmB,EAAgBjB,EAAhBO,GACAS,IAAKN,EAAL,CAAAH,EAAAC,KAAAD,EAAAC,MACIS,EAAAA,MAAkBf,EAKlBI,EAAWI,KAAKH,EAAY,IAJzBU,EAAkBT,MAAGA,KAAA,GAQxBF,EAAWI,KAAKH,EAAY,GAP9BU,EAAAA,KAAkBf,EAAUK,IAI3B,IAFD,IAEOI,EAAIJ,EAAAA,EAASD,EAAWE,OAAxBG,IACLL,MAAAA,EAAgBC,GAAAA,IAAhBA,EADKK,MAEAL,EAAA,IAAAD,EAAAK,IAUDE,eAAeK,eAAed,QAN/BS,eAAeP,eAAWG,SAUhBU,EAAXR,GAAAG,KAAAN,MAAA,GAAAF,EAAAK,KAAAL,EAAWa,OAAOR,EAAG,GANvBA,KAYDM,IAGD,IAAK,IAAIN,EAAI,EAAGA,EAAIL,EAAWG,OAAQE,IADvCM,GAAAA,EAAeX,EAAAK,KAAAM,EAAA,CAGXD,KAAKN,KAAKJ,EAAWK,IAFzB,MAGIJ,EAAAS,KAAAA,KAAAP,OAAA,GAMN,IAAK,IAAIE,EAAI,EAAGF,EAASO,KAAKP,OAAQE,EAAIF,EAAQE,IAAK,CAHrDJ,IAAAA,EAAAA,KAAYS,MAAKA,KAAKP,GAALD,MAClBY,EAAAJ,KAAAL,GAAAH,KAKCQ,KAAKL,GAAK,CAHZS,EAAAA,EACEC,EAAAA","file":"shortestPath.min.js","sourcesContent":["function findShortestLength(startIndex, endIndex) {\r\n  let queue = [];\r\n  let distances = new Array(rows * cols).fill(-1);\r\n  queue.push(startIndex);\r\n  distances[startIndex] = 0;\r\n  let comb1, comb2;\r\n  while (queue.length > 0) {\r\n    let cellIndex = queue.shift();\r\n    let neighbours = [cellIndex - cols, cellIndex + cols];\r\n    if (cellIndex % cols == 0) {\r\n      neighbours.push(cellIndex + 1);\r\n    } else if (cellIndex % cols == cols - 1) {\r\n      neighbours.push(cellIndex - 1);\r\n    } else {\r\n      neighbours.push(cellIndex + 1);\r\n      neighbours.push(cellIndex - 1);\r\n    }\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      // console.log(\r\n      //   \"index\",\r\n      //   i,\r\n      //   neighbours[i],\r\n      //   comb1,\r\n      //   removedWallSet.hasOwnProperty(comb1),\r\n      //   comb2,\r\n      //   removedWallSet.hasOwnProperty(comb2)\r\n      // );\r\n\r\n      comb1 = neighbours[i] + \"_\" + cellIndex;\r\n      comb2 = cellIndex + \"_\" + neighbours[i];\r\n\r\n      if (!(removedWallSet[comb1] || removedWallSet[comb2])) {\r\n        neighbours.splice(i, 1);\r\n        i--;\r\n      } else if (!(neighbours[i] < rows * cols && neighbours[i] >= 0)) {\r\n        neighbours.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      if (distances[neighbours[i]] == -1) {\r\n        distances[neighbours[i]] = distances[cellIndex] + 1;\r\n        queue.push(neighbours[i]);\r\n        if (neighbours[i] == endIndex) {\r\n          return distances;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction findShortestPath(startIndex, endIndex) {\r\n  let distances = findShortestLength(startIndex, endIndex);\r\n  let cellIndex = endIndex;\r\n  path.push(endIndex);\r\n  let currentDistance = distances[endIndex];\r\n  while (currentDistance > 0) {\r\n    currentDistance = distances[cellIndex];\r\n    let neighbours = [cellIndex - cols, cellIndex + cols];\r\n    if (cellIndex % cols == 0) {\r\n      neighbours.push(cellIndex + 1);\r\n    } else if (cellIndex % cols == cols - 1) {\r\n      neighbours.push(cellIndex - 1);\r\n    } else {\r\n      neighbours.push(cellIndex + 1);\r\n      neighbours.push(cellIndex - 1);\r\n    }\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      comb1 = neighbours[i] + \"_\" + cellIndex;\r\n      comb2 = cellIndex + \"_\" + neighbours[i];\r\n\r\n      if (\r\n        !(\r\n          removedWallSet.hasOwnProperty(comb1) ||\r\n          removedWallSet.hasOwnProperty(comb2)\r\n        )\r\n      ) {\r\n        neighbours.splice(i, 1);\r\n        i--;\r\n      } else if (!(neighbours[i] < rows * cols && neighbours[i] >= 0)) {\r\n        neighbours.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n\r\n    currentDistance--;\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      if (distances[neighbours[i]] == currentDistance) {\r\n        path.push(neighbours[i]);\r\n        break;\r\n      }\r\n    }\r\n    cellIndex = path[path.length - 1];\r\n  }\r\n\r\n  for (let i = 0, length = path.length; i < length; i++) {\r\n    let y = Math.floor(path[i] / cols);\r\n    let x = path[i] % cols;\r\n    path[i] = {\r\n      x,\r\n      y,\r\n    };\r\n  }\r\n}\r\n"]}